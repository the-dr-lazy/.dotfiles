#+title: DOOM Emacs Configuration
#+subtitle: The Methods, Management, and Menagerie@@latex:\\@@ of Madness@@latex: --- in meticulous detail@@
#+author: the-dr-lazy
#+date: @@html:<!--@@{{{git-rev}}}@@html:-->@@@@latex:\\\Large\bfseries@@ {{{modification-time(%Y-%m-%d, t)}}} @@latex:\\\normalsize\mdseries@@{{{modification-time(%H:%M, t)}}} @@latex:\acr{\lowercase{@@{{{timezone}}}@@latex:}}\iffalse@@, {{{git-rev}}}@@latex:\fi@@
#+macro: timezone (eval (substring (shell-command-to-string "date +%Z") 0 -1))
#+macro: git-rev (eval (format "@@html:<a href=\"https://github.com/tecosaur/emacs-config/commit/%1$s\" style=\"text-decoration: none\"><code style=\"padding: 0; color: var(--text-light); font-size: inherit; opacity: 0.7\">%1$s</code></a>@@@@latex:\\href{https://github.com/tecosaur/emacs-config/commit/%1$s}{\\normalsize\\texttt{%1$s}}@@" (substring (shell-command-to-string "git rev-parse --short HEAD") 0 -1)))
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args :tangle no :results silent :eval no-export
#+options: coverpage:yes
#+startup: fold

* Rudimentary Configuration

  Make
  this
  file
  run
  (slightly)
  faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]] for more info).
#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

** Personal Information
It's useful to have some basic personal information
#+begin_src emacs-lisp
(setq user-full-name "Mohammad Hasani"
user-mail-address "the-dr-lazy@pm.me")
#+end_src
These are used for a number of things, particularly for ~GPG~ configuration, some email clients, file templates and snippets.

Speaking of ~GPG~, I want to use =~/.authsource.gpg= instead of the default in
=~/.emacs.d=. Why? Because my home directory is already cluttered, so this won't
make a difference, and I don't want to accidentaly purge this file (I have done
src_shell{rm -rf~/.emac.d~ before}. I also want to cache as much as possible, as
my home machine is pretty safe, and my laptop is shutdown a lot.
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

** Better Defaults
*** Simple settings
Browsing the web and seeing [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]] and comparing with the values
shown by =SPC h v= and selecting what I thought looks good, I've ended up adding
the following:

#+begin_src emacs-lisp
(setq-default
delete-by-moving-to-trash t                      ; Delete files to trash
window-combination-resize t                      ; take new window space from all other windows (not just current)
x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
auto-save-default t                         ; Nobody likes to loose work, I certainly don't
truncate-string-ellipsis "…"                ; Unicode ellispis are nicer than "...", and also save /precious/ space
password-cache-expiry nil                   ; I can trust my computers ... can't I?
;; scroll-preserve-screen-position 'always     ; Don't have `point' jump around
scroll-margin 2)                            ; It's nice to maintain a little margin

(global-auto-revert-mode t)                       ; Automatically update buffers
(display-time-mode 1)                             ; Enable time in the mode-line
(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

*** Frame sizing
It's nice to control the size of new frames, when launching Emacs that can be
done with src_shell{emacs -geometry 160x48}. After the font size adjustment
during initialisation this works out to be ~102x31~.

Thanks to hotkeys, it's easy for me to expand a frame to half/full-screen, so it
makes sense to be conservative with the sizing of new frames.

Then, for creating new frames within the same Emacs instance, we'll just set the
default to be something roughly 80% of that size.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src

*** Auto-customisation
By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
(load custom-file))
#+end_src
*** Windows
First, we'll enter the new window
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
evil-split-window-below t)
#+end_src

Window rotation is nice, and can be found under =SPC w r= and =SPC w R=.
/Layout/ rotation is also nice though. Let's stash this under =SPC w SPC=, inspired
by Tmux's use of =C-b SPC= to rotate windows.

We could also do with adding the missing arrow-key variants of the window
navigation/swapping commands.
#+begin_src emacs-lisp
(map! :map evil-window-map
"SPC" #'rotate-layout)
#+end_src
*** Buffer defaults
I'd much rather have my new buffers in ~org-mode~ than ~fundamental-mode~, hence
#+begin_src emacs-lisp
;; (setq-default major-mode 'org-mode)
#+end_src
For some reason this + the mixed pitch hook causes issues with hydra and so I'll
just need to resort to =SPC b o= for now.
** Doom Configuration
*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Doom has this lovely /modular configuration base/ that takes a lot of work out of
configuring Emacs. Each module (when enabled) can provide a list of packages to
install (on ~doom sync~) and configuration to be applied. The modules can also
have flags applied to tweak their behaviour.

#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

(doom! :input
<<doom-input>>

:completion
<<doom-completion>>

:ui
<<doom-ui>>

:editor
<<doom-editor>>

:emacs
<<doom-emacs>>

:term
<<doom-term>>

:checkers
<<doom-checkers>>

:tools
<<doom-tools>>

:os
<<doom-os>>

:lang
<<doom-lang>>

:app
<<doom-app>>

:config
<<doom-config>>
)
#+end_src
Press =K= on a module to view its documentation, and =gd= to browse its directory.

**** Structure
As you may have noticed by this point, this is a [[https://en.wikipedia.org/wiki/Literate_programming][literate]] configuration. Doom
has good support for this which we access though the ~literate~ module.

While we're in the src_elisp{:config} section, we'll use Dooms nicer defaults,
along with the bindings and smartparens behaviour (the flags aren't documented,
but they exist).
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Interface
There's a lot that can be done to enhance Emacs' capabilities.
I reckon enabling half the modules Doom provides should do it.

#+name: doom-completion
#+begin_src emacs-lisp
company          ; the ultimate code completion backend
(vertico +icons) ; the search engine of the future
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
deft              ; notational velocity for Emacs
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
doom-quit         ; DOOM quit-message prompts when you quit Emacs
(ligatures +extra)           ; ligatures and symbols to make your code pretty again
(emoji +unicode)             ; 🙂
unicode
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
indent-guides     ; highlighted indent columns
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash         ; blink cursor line after big motions
ophints           ; highlight the region an operation acts on
(popup                       ; tame sudden yet inevitable temporary windows
+all                        ; catch all popups that start with an asterix
+defaults)                  ; default popup rules
treemacs          ; a project drawer, like neotree but cooler
vc-gutter                    ; vcs diff in the fringe
vi-tilde-fringe              ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
(format +onsave)  ; automated prettiness
multiple-cursors             ; editing in many places at once
rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
word-wrap         ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
dired             ; making dired pretty [functional]
electric                     ; smarter, keyword-based electric-indent
(ibuffer +icons)             ; interactive buffer management
(undo +tree)                 ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
vterm                        ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax                       ; tasing you for every semicolon you forget
(:if (executable-find "aspell")
(spell         ; tasing you for misspelling mispelling
+aspell))     ; Use aspell as a backend for correcting words.
;;  +everywhere)) ; Spell check in programming modes as well (in comments).
grammar                      ; tasing grammar mistake every you make
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)  ; improve compatibility with macOS
#+end_src
**** Tools
#+name: doom-tools
#+begin_src emacs-lisp
debugger          ; stepping through code, to help you add bugs
direnv ; be direct about your environment
docker ; port everything to containers
editorconfig      ; let someone else argue about tabs vs spaces
(eval +overlay)              ; run code, run (also, repls)
(lookup                      ; helps you navigate your code and documentation
+dictionary                 ; dictionary/thesaurus is nice
+docsets)                   ; ...or in Dash docsets locally
lsp                          ; Language Server Protocol
(magit                       ; a git porcelain for Emacs
+forge)                     ; interface with git forges
make                         ; run make tasks from Emacs
pdf                          ; pdf enhancements
rgb                          ; creating color strings
upload                       ; map local to remote projects via ssh/ftp
tree-sitter                  ; syntax and parsing, sitting in a tree...
biblio
#+end_src

**** Language Support
We can be rather liberal with enabling support for languages as the associated
packages/configuration are (usually) only loaded when first opening an
associated file.

#+name: doom-lang
#+begin_src emacs-lisp
(cc
+lsp
+tree-sitter)                ; C/C++/Obj-C madness
data              ; config/data formats
(elm
+lsp
+tree-sitter)               ; care for a cup of TEA?
emacs-lisp                   ; drown in parentheses
(haskell +lsp)  ; a language that's lazier than I am
idris
(json
+lsp
+tree-sitter)              ; At least it ain't XML
(web                    ; the tubes
+lsp
+css
+html
+tree-sitter)
(javascript
+lsp
+tree-sitter)        ; all(hope(abandon(ye(who(enter(here))))))
(latex                       ; writing papers in Emacs has never been so fun
+latexmk                    ; what else would you use?
+cdlatex                    ; quick maths symbols
+fold)                      ; fold the clutter away nicities
markdown                     ; writing docs for people to ignore
(nix +tree-sitter)               ; I hereby declare "nix geht mehr!"
(org                         ; organize your plain life in plain text
+pretty                     ; yessss my pretties! (nice unicode symbols)
+dragndrop                  ; drag & drop files/images into org buffers
+noter                      ; enhanced PDF notetaking
+pandoc                     ; export-with-pandoc support
+gnuplot                    ; who doesn't like pretty pictures
+pomodoro                   ; be fruitful with the tomato technique
+present                    ; using org-mode for presentations
+roam2)                     ; wander around notes
(purescript +lsp)        ; javascript, but functional
(sh
+lsp
+tree-sitter)                ; she sells {ba,z,fi}sh shells on the C xor
yaml                         ; JSON, but readable
dhall
ledger
#+end_src
**** Everything In Emacs
It's just too convenient being able to have everything in Emacs.
I couldn't resist the Feed module.

#+name: doom-app
#+begin_src emacs-lisp
calendar                   ; A dated approach to timetabling
everywhere                   ; *leave* Emacs!? You must be joking.
irc                          ; how neckbeards socialize
(rss +org)                   ; emacs as an RSS reader
#+end_src

*** Visual Settings
**** Font Face
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "VictorMono Nerd Font" :size 18)
doom-big-font (font-spec :family "VictorMono Nerd Font" :size 24)
doom-variable-pitch-font (font-spec :family "Overpass" :size 19)
doom-unicode-font (font-spec :family "JuliaMono")
doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light))
#+end_src

I'm persian! Unfortunately. So I have better intuition over persian fonts than =unicode-fonts=.
#+begin_src emacs-lisp
(after! unicode-fonts
(push "Farhang" (cadr (assoc "Arabic" unicode-fonts-block-font-mapping))))
;; (after! unicode-fonts
;;   (add-to-list unicode-fonts-block-font-mapping '("Arabic" . '("Farhang"))))
#+end_src

In addition to these fonts, Merriweather is used with =nov.el=, and Alegreya as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

Because we care about how things look let's add a check to make sure we're told
if the system doesn't have any of those fonts.
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("VictorMono Nerd Font" "Farhang" "Overpass" "JuliaMono" "IBM Plex Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
(delete-dups (or (font-family-list)
(split-string (shell-command-to-string "fc-list : family")
"[,\n]"))))

(defvar missing-fonts
(delq nil (mapcar
(lambda (font)
(unless (delq nil (mapcar (lambda (f)
(string-match-p (format "^%s$" font) f))
available-fonts))
font))
required-fonts)))

(if missing-fonts
(pp-to-string
`(unless noninteractive
(add-hook! 'doom-init-ui-hook
(run-at-time nil nil
(lambda ()
(message "%s missing the following fonts: %s"
(propertize "Warning!" 'face '(bold warning))
(mapconcat (lambda (font)
(propertize font 'face 'font-lock-variable-name-face))
',missing-fonts
", "))
(sleep-for 0.5))))))
";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts()>>
#+end_src
This way whenever fonts are missing, after Doom's UI has initialised, a warning
listing the missing fonts should appear for at least half a second.

Also, let's add some flavour to comments and keywords in the syntax.
#+begin_src emacs-lisp
(custom-set-faces!
'(font-lock-comment-face :slant italic)
'(font-lock-keyword-face :slant italic))
#+end_src

**** Bidirectional Editing
#+begin_src emacs-lisp
(defun set-bidi-env ()
(setq bidi-paragraph-direction 'nil
bidi-paragraph-separate-re "^"
bidi-paragraph-start-re "^"))

(add-hook! 'org-mode-hook 'set-bidi-env)
(add-hook! 'latex-mode-hook 'set-bidi-env)
(add-hook! 'markdown-mode-hook 'set-bidi-env)
#+end_src
**** Theme and Modeline
~doom-one~ is nice and all, but I find the ~moonlight~ variant nicer. Oh, and with the
nice selection doom provides there's no reason for me to want the defaults.
#+begin_src emacs-lisp
(setq doom-theme 'doom-moonlight)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)
(after! doom-themes
(setq doom-themes-enable-bold t
doom-themes-enable-italic t))

(after! doom-modeline
(setq doom-modeline-bar-width 3
doom-modeline-buffer-file-name-style 'file-name
doom-modeline-icon t
doom-modeline-major-mode-icon t))
#+end_src

However, by default ~red~ text is used in the ~modeline~, so let's make that orange
so I don't feel like something's gone /wrong/ when editing files.
#+begin_src emacs-lisp
(custom-set-faces!
'(doom-modeline-buffer-modified :foreground "orange"))
#+end_src

**** Window Title
I'd like to have just the buffer name, then if applicable the project folder
#+begin_src emacs-lisp
(setq frame-title-format
'(""
(:eval
(if (s-contains-p org-roam-directory (or buffer-file-name ""))
(replace-regexp-in-string
".*/[0-9]*-?" "☰ "
(subst-char-in-string ?_ ?  buffer-file-name))
"%b"))
(:eval
(let ((project-name (projectile-project-name)))
(unless (string= "-" project-name)
(format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

For example when I open my config file it the window will be titled =config.org ●
doom= then as soon as I make a change it will become =config.org ◉ doom=.
**** Splash Screen
Emacs can render an image as the splash screen! You know that fancy GNU head, ha? :)

#+begin_src emacs-lisp
(setq fancy-splash-image (concat doom-private-dir "media/gnu.png"))
#+end_src

Lastly, the doom dashboard "useful commands" are no longer useful to me.
So, we'll disable them and then for a particularly /clean/ look disable
the modeline and ~hl-line-mode~, then also hide the cursor.

#+begin_src emacs-lisp
(setq +doom-dashboard-functions '(doom-dashboard-widget-banner))
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src
**** Ligatures
#+begin_src emacs-lisp
(setq +ligatures-extra-symbols
'(;; Functional
:lambda "λ"
:delta "∆"
:left-composition "ᗕ"
:right-composition "ᗒ"
:function "ƒ"
;; Logical
:forall "∀"
:exists "∃"
:not "¬"
:and "∧"
:or "∨"
:import "⟼"
:export "⟻"
;; Algebraic
:not-equal "≠"
;; Types
:int "ℤ"
:void "∅"
:bool "𝔹"
:true "𝕋"
:false "𝔽"
:bottom "⊥"
;; Brand
:monarch "⋈"))
#+end_src
**** Miscellaneous
Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

I'd like some slightly nicer default buffer names
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "► Doom"
+doom-dashboard-name "► Doom")
#+end_src

*** Some Helper Macros
There are a few handy macros added by doom, namely
- ~load!~ for loading external ~.el~ files relative to this one
- ~use-package!~ for configuring packages
- ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
you load packages with ~require~ or ~use-package~
- ~map!~ for binding new keys
*** Allow Babel Execution In CLI Actions
In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
(quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src
*** Asynchronous Config Tangling
Doom adds an =org-mode= hook ~+literate-enable-recompile-h~. This is a nice idea,
but it's too blocking for my taste. Since I trust my tangling to be fairly
straightforward, I'll just redefine it to a simpler, async, function.
#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
"A very simplified version of `+literate-tangle-h', but async."
:override #'+literate-tangle-h
(let ((default-directory doom-private-dir))
(async-shell-command
(format "emacs --batch --eval \"(progn \
(require 'org) (setq org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
+literate-config-file))))
#+end_src

* Packages
This is where you install packages, by declaring them with the ~package!~ macro in
=packages.el=, then running ~doom refresh~ on the command line.
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

You'll then need to restart Emacs for your changes to take effect! Or at least,
run =M-x doom/reload=.

*Warning*: Don't disable core packages listed in =~/.emacs.d/core/packages.el=.
Doom requires these, and disabling them may have terrible side effects.
** Loading Instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
*** Packages In MELPA/ELPA/emacsmirror
To install ~some-package~ from MELPA, ELPA or emacsmirror:
#+begin_src emacs-lisp
(package! some-package)
#+end_src

*** Packages From Git Repositories
To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! another-package
:recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:
#+begin_src emacs-lisp
(package! this-package
:recipe (:host github :repo "username/repo"
:files ("some-file.el" "src/lisp/*.el")))
#+end_src

*** Disabling and Overriding Built-in Packages
If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't 'master' (which
our package manager can't deal with; see [[https://github.com/raxod502/straight.el/issues/279][raxod502/straight.el#279]])
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src

** Convenience
*** Rotate (window management)
The =rotate= package just adds the ability to rotate window layouts, but that
sounds nice to me.
#+begin_src emacs-lisp :tangle packages.el
(package! rotate
:pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src

*** Which-key
#+begin_quote
From the =:core packages= module.
#+end_quote

Let's make this popup a bit faster
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.8) ;; I need the help, I really do
#+end_src

I also think that having =evil-= appear in so many popups is a bit too verbose,
let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
(pushnew!
which-key-replacement-alist
'(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
'(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
))
#+end_src

#+attr_html: :class invertible :alt Whichkey triggered on an evil motion
[[https://tecosaur.com/lfs/emacs-config/screenshots/whichkey-evil.png]]

** Tools
*** GPG
#+begin_src emacs-lisp :tangle packages.el
(package! pinentry)
#+end_src

#+begin_src emacs-lisp
(setq epg-pinentry-mode 'loopback)
(pinentry-start)
#+end_src
*** Abbrev
Thanks to [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][use a single abbrev-table for multiple modes? - Emacs Stack Exchange]] I
have the following.
#+begin_src emacs-lisp :tangle no
(add-hook 'doom-first-buffer-hook
(defun +abbrev-file-name ()
(setq-default abbrev-mode t)
(setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src
*** Very Large Files
The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.
#+begin_src emacs-lisp :tangle packages.el
(package! vlf
:recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
:pin "cc02f2533782d6b9b628cec7e2dcf25b2d05a27c")
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.
#+begin_src emacs-lisp
(use-package! vlf-setup
:defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

*** Eros
#+begin_quote
From the =:tools eval= module.
#+end_quote

This package enables the very nice inline evaluation with =gr= and =gR=. The prefix
could be slightly nicer though.
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "==> ") ; default =>
#+end_src
*** EVIL
#+begin_quote
From the =:editor evil= module.
#+end_quote

When I want to make a substitution, I want it to be global more often than not
--- so let's make that the default.
Now, EVIL cares a fair bit about keeping compatibility with Vim's default
behaviour. I don't. There are some particular settings that I'd rather be
something else, so let's change them.
#+begin_src emacs-lisp
(after! evil
(setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
evil-move-beyond-eol t
evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

EVIL by default uses =forwar-char= and =backward-char= commands which are not bidi-aware. (https://github.com/emacs-evil/evil/issues/892)
#+begin_src emacs-lisp
(setq visual-order-cursor-movement t)
(define-key evil-normal-state-map "h" 'left-char)
(define-key evil-normal-state-map "l" 'right-char)
(define-key evil-normal-state-map [left] 'left-char)
(define-key evil-normal-state-map [right] 'right-char)
(define-key evil-visual-state-map "h" 'left-char)
(define-key evil-visual-state-map "l" 'right-char)
(define-key evil-visual-state-map [left] 'left-char)
(define-key evil-visual-state-map [right] 'right-char)
#+end_src

*** Consult
#+begin_quote
From the =:completion vertico= module.
#+end_quote

Since we're using [[Marginalia]] too, the separation between buffers and files is
already clear, and there's no need for a different face.

#+begin_src emacs-lisp
(after! consult
(set-face-attribute 'consult-file nil :inherit 'consult-buffer)
(setf (plist-get (alist-get 'perl consult-async-split-styles-alist) :initial) ";"))
#+end_src
*** Smerge
For repeated operations, a hydra would be helpful. But I prefer transient.
#+begin_src emacs-lisp
(defun smerge-repeatedly ()
"Perform smerge actions again and again"
(interactive)
(smerge-mode 1)
(smerge-transient))

(after! transient
(transient-define-prefix smerge-transient ()
[["Move"
("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (smerge-repeatedly)))
("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev)) (smerge-repeatedly)))]
["Keep"
("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
["Diff"
("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
(">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
["Other"
("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

*** Company
#+begin_quote
From the =:completion company= module.
#+end_quote

It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!
#+begin_src emacs-lisp
(after! company
(setq company-idle-delay 0.5
company-minimum-prefix-length 2)
(setq company-show-numbers t)
(add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src

Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

**** Plain Text
~Ispell~ is nice, let's have it in ~text~, ~markdown~, and ~GFM~.
#+begin_src emacs-lisp
(set-company-backend!
'(text-mode
markdown-mode
gfm-mode)
'(:seperate
company-ispell
company-files
company-yasnippet))
#+end_src
We then configure the dictionary we're using in [[*Ispell][Ispell]].
*** Projectile
#+begin_quote
From the =:core packages= module.
#+end_quote

Looking at documentation via =SPC h f= and =SPC h v= and looking at the source can
add package src directories to projectile. This isn't desirable in my opinion.
#+begin_src emacs-lisp
(setq projectile-ignored-projects '("~/" "/tmp" "~/.emacs.d/.local/straight/repos/"))
(defun projectile-ignored-project-function (filepath)
"Return t if FILEPATH is within any of `projectile-ignored-projects'"
(or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src
*** Auto activating snippets
Sometimes pressing =TAB= is just too much.
#+begin_src emacs-lisp :tangle packages.el
(package! aas
:recipe (:host github :repo "ymarco/auto-activating-snippets")
:pin "118ed7fc948b6d91eea727df35a1639521bf5fdb")
#+end_src
#+begin_src emacs-lisp
(use-package! aas
:commands aas-mode)
#+end_src
*** Screenshot
This makes it a breeze to take lovely screenshots.
#+begin_src emacs-lisp :tangle packages.el
(package! screenshot
:recipe (:host github :repo "tecosaur/screenshot")
:pin "41b92a2a885d517fc14626dd0e666ae9ca20e529")
#+end_src

#+attr_html: :class invertible :alt Example screenshot.el screenshot
[[https://tecosaur.com/lfs/emacs-config/screenshots/screenshot.png]]

Some light configuring is all we need, so we can make use of the [[[https://github.com/Calinou/0x0][0x0]] wrapper
file uploading script.
#+begin_src emacs-lisp
(use-package! screenshot
:defer t
:config (setq screenshot-upload-fn "0x0 %s 2>/dev/null"))
#+end_src
*** YASnippet
#+begin_quote
From the =:editor snippets= module.
#+end_quote

Nested snippets are good, so let's enable that.
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src
*** String inflection
For when you want to change the case pattern for a symbol.
#+begin_src emacs-lisp :tangle packages.el
(package! string-inflection
:pin "c4a519be102cb99dd86be3ee8c387f008d097635")
#+end_src

#+begin_src emacs-lisp
(use-package! string-inflection
:commands (string-inflection-all-cycle
string-inflection-toggle
string-inflection-camelcase
string-inflection-lower-camelcase
string-inflection-kebab-case
string-inflection-underscore
string-inflection-capital-underscore
string-inflection-upcase)
:init
(map! :leader :prefix ("c~" . "naming convention")
:desc "cycle" "~" #'string-inflection-all-cycle
:desc "toggle" "t" #'string-inflection-toggle
:desc "CamelCase" "c" #'string-inflection-camelcase
:desc "downCase" "d" #'string-inflection-lower-camelcase
:desc "kebab-case" "k" #'string-inflection-kebab-case
:desc "under_score" "_" #'string-inflection-underscore
:desc "Upper_Score" "u" #'string-inflection-capital-underscore
:desc "UP_CASE" "U" #'string-inflection-upcase)
(after! evil
(evil-define-operator evil-operator-string-inflection (beg end _type)
"Define a new evil operator that cycles symbol casing."
:move-point nil
(interactive "<R>")
(string-inflection-all-cycle)
(setq evil-repeat-info '([?g ?~])))
(define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection)))
#+end_src
*** Smart parentheses
#+begin_quote
From the =:core packages= module.
#+end_quote

#+begin_src emacs-lisp
(sp-local-pair
'(org-mode)
"<<" ">>"
:actions '(insert))
#+end_src
*** Auto formatter
#+begin_src emacs-lisp
(setq +format-on-save-enabled-modes
'(not emacs-lisp-mode  ; elisp's mechanisms are good enough
sql-mode         ; sqlformat is currently broken
tex-mode         ; latexindent is broken
latex-mode
typescript-mode
typescript-tsx-mode
tsx-mode))

(use-package! format-all
;; To enable format on save for most programming language buffers:
;; :hook (prog-mode . format-all-mode)
:config
;; Please use the default formatters; I don't care too much.
(add-hook! 'format-all-mode-hook 'format-all-ensure-formatter))


;; (use-package! apheleia
;;   :hook ((tsx-mode . apheleia-mode)
;;          (typescript-mode . apheleia-mode)
;;          (js-mode . apheleia-mode)
;;          (json-mode . apheleia-mode)
;;          (css-mode . apheleia-mode)
;;          (scss-mode . apheleia-mode))
;;   :defer t
;;   :config
;;   (push '(tsx-mode . prettier) apheleia-mode-alist)
;;   (push '(scss-mode . prettier) apheleia-mode-alist)
;;   (push '(css-mode . prettier) apheleia-mode-alist))
#+end_src
** Visuals
*** LSP
#+begin_src emacs-lisp
(after! lsp-ui
(setq lsp-ui-doc-enable t
lsp-ui-doc-delay 0
lsp-ui-doc-position 'top
lsp-ui-doc-include-signature t
lsp-ui-doc-show-with-cursor t
lsp-ui-doc-show-with-mouse nil
lsp-ui-doc-max-width 89
lsp-ui-doc-max-height 8
lsp-ui-doc-border "#ffffff")
(set-face-background 'lsp-ui-doc-background "#191b2e"))

(after! lsp-mode
(setq lsp-signature-auto-activate nil
lsp-signature-render-documentation nil
lsp-eldoc-hook nil
lsp-modeline-diagnostics-scope :workspace))

(setq +lookup-open-url-fn #'+lookup-xwidget-webkit-open-url-fn)
#+end_src
*** Info Colours
This makes manual pages nicer to look at by adding variable pitch fontification
and colouring. :)

#+attr_html: :class invertible :style width:80% :alt Example info-colours page.
[[https://tecosaur.com/lfs/emacs-config/screenshots/info-colours.png]]

#+begin_src emacs-lisp :tangle packages.el
(package! info-colors
:pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src

To use this we'll just hook it into =Info=.

#+begin_src emacs-lisp
(use-package! info-colors :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

#+attr_html: :class invertible :alt Example colourised info page
[[https://tecosaur.com/lfs/emacs-config/screenshots/info-coloured.png]]
*** Theme Magic
With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp :tangle packages.el
(package! theme-magic
:pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

Let's automatically update terminals on theme change (as long as ~pywal~ is available).

Unfortunately, as the theme is set on startup this causes the hook to be run
immediately. It would be nicer to /not/ have this add to our precious startup
time (around 0.4s last time I checked).
We can achieve this by deferring it with a short idle timer that should add the
hook /just after/ initialisation.
#+begin_src emacs-lisp :tangle (if (executable-find "wal") "yes" "no")
(run-with-idle-timer 0.1 nil (lambda () (add-hook 'doom-load-theme-hook 'theme-magic-from-emacs)))
#+end_src
*** Emojify
#+begin_quote
From the =:ui emoji= module.
#+end_quote

For starters, twitter's emojis look nicer than emoji-one.
Other than that, this is pretty great OOTB 😀.

#+begin_src emacs-lisp
(setq emojify-emoji-set "twemoji-v2")
#+end_src

One minor annoyance is the use of emojis over the default character
when the default is actually preferred. This occurs with overlay symbols I use
in Org mode, such as checkbox state, and a few other miscellaneous cases.

We can accommodate our preferences by deleting those entries from the emoji hash
table

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
'(;; Org
"◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓"
;; Terminal powerline
"✔"
;; Box drawing
"▶" "◀")
"Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
"Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
:after #'emojify-set-emoji-data
(dolist (emoji emojify-disabled-emojis)
(remhash emoji emojify-emojis)))
#+end_src
*** Doom Modeline
#+begin_quote
From the =:ui modeline= module.
#+end_quote

While we're modifying the modeline, =LF UTF-8= is the default file encoding, and
thus not worth noting in the modeline. So, let's conditionally hide it.
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
"We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
(setq-local doom-modeline-buffer-encoding
(unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
'(coding-category-undecided coding-category-utf-8))
(not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

Very nice and pretty, however I think the PDF modeline could do with tweaking.
I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this, however the response was basically "put your
preferences in your personal config, the current default is sensible" --- so
here we are.
First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.
#+begin_src emacs-lisp
(after! doom-modeline
(doom-modeline-def-segment buffer-name
"Display the current buffer's name, without any other information."
(concat
(doom-modeline-spc)
(doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
"PDF icon from all-the-icons."
(concat
(doom-modeline-spc)
(doom-modeline-icon 'octicon "file-pdf" nil nil
:face (if (doom-modeline--active)
'all-the-icons-red
'mode-line-inactive)
:v-adjust 0.02)))

(defun doom-modeline-update-pdf-pages ()
"Update PDF pages."
(setq doom-modeline--pdf-pages
(let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
(total-page-str (number-to-string (pdf-cache-number-of-pages))))
(concat
(propertize
(concat (make-string (- (length total-page-str) (length current-page-str)) ? )
" P" current-page-str)
'face 'mode-line)
(propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
"Display PDF pages."
(if (doom-modeline--active) doom-modeline--pdf-pages
(propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
'(bar window-number pdf-pages pdf-icon buffer-name)
'(misc-info matches major-mode process vcs)))
#+end_src
*** Indent Guides
#+begin_quote
From the =:ui indent-guides= module.
#+end_quote

Columnar indent guides are so helpful; Let's use it.
#+begin_src emacs-lisp
(setq highlight-indent-guides-method 'column)
#+end_src
*** Highlight ToDos
#+begin_quote
From the =:ui hl-todo= module.
#+end_quote

Making some keywords (e.g. ToDo, Hack and etc.) in the comments look different is a good idea!
#+begin_src emacs-lisp
(after! hl-todo
(setq hl-todo-keyword-faces '(("ToDo" warning bold)
("TODO" warning bold)

("Note" success bold)
("NOTE" success bold)

("See Note" markdown-url-face)
("SEE NOTE" markdown-url-face)

("Hack" font-lock-constant-face bold)
("HACK" font-lock-constant-face bold)

("FIXME" error bold)

("Deprecated" font-lock-doc-face bold)
("DEPRECATED" font-lock-doc-face bold)

("Bug" error bold)
("BUG" error bold)

("XXX+" font-lock-constant-face bold))))
#+end_src
*** Mixed Pitch

#+begin_quote
From the =:ui zen= module.
#+end_quote

We'd like to use mixed pitch in certain modes. If we simply add a hook, when
directly opening a file with (a new) Emacs =mixed-pitch-mode= runs before UI
initialisation, which is problematic. To resolve this, we create a hook that
runs after UI initialisation and both
+ conditionally enables =mixed-pitch-mode=
+ sets up the mixed pitch hooks

#+begin_src emacs-lisp
(defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
"Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
"Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
(when (memq major-mode mixed-pitch-modes)
(mixed-pitch-mode 1))
(dolist (hook mixed-pitch-modes)
(add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

As mixed pitch uses the variable =mixed-pitch-face=, we can create a new function
to apply mixed pitch with a serif face instead of the default (see the
subsequent face definition). This was created for writeroom mode.

#+begin_src emacs-lisp
(autoload #'mixed-pitch-serif-mode "mixed-pitch"
"Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(setq! variable-pitch-serif-font (font-spec :family "Alegreya" :size 27))

(after! mixed-pitch
(setq mixed-pitch-set-height t)
(set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
(defun mixed-pitch-serif-mode (&optional arg)
"Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
(interactive)
(let ((mixed-pitch-face 'variable-pitch-serif))
(mixed-pitch-mode (or arg 'toggle)))))
#+end_src

Now, as Harfbuzz is currently used in Emacs, we'll be missing out on the
following Alegreya ligatures:
#+begin_center
ff /ff/ ffi /ffi/ ffj /ffj/ ffl /ffl/
fft /fft/ fi /fi/ fj /fj/ ft /ft/
Th /Th/
#+end_center

Thankfully, it isn't to hard to add these to the ~composition-function-table~.
#+begin_src emacs-lisp
(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijlt]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src

**** Variable pitch serif font

#+call: confpkg()

It would be nice if we were able to make use of a serif version of the
=variable-pitch= face. Since this doesn't already exist, let's create it.

#+begin_src emacs-lisp
(defface variable-pitch-serif
'((t (:family "serif")))
"A variable-pitch face with serifs."
:group 'basic-faces)
#+end_src

For ease of use, let's also set up an easy way of setting the ~:font~ attribute.

#+begin_src emacs-lisp
(defcustom variable-pitch-serif-font (font-spec :family "serif")
"The font face used for `variable-pitch-serif'."
:group 'basic-faces
:set (lambda (symbol value)
(set-face-attribute 'variable-pitch-serif nil :font value)
(set-default-toplevel-value symbol value)))
#+end_src

*** Prettier Page Breaks
In some files, =^L= appears as a page break character. This isn't that visually
appealing, and Steve Purcell has been nice enough to make a package to display
these as horizontal rules.
#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines"))
#+end_src

#+begin_src emacs-lisp
(use-package! page-break-lines
:commands page-break-lines-mode
:init
(autoload 'turn-on-page-break-lines-mode "page-break-lines")
:config
(setq page-break-lines-max-width fill-column)
(map! :prefix "g"
:desc "Prev page break" :nv "[" #'backward-page
:desc "Next page break" :nv "]" #'forward-page))
#+end_src
*** Writeroom
#+begin_quote
From the =:ui zen= module.
#+end_quote

For starters, I think Doom is a bit over-zealous when zooming in
#+begin_src emacs-lisp
(setq +zen-text-scale 0.5)
#+end_src

Then, when using Org it would be nice to make a number of other aesthetic
tweaks. Namely:
+ Use a serifed variable-pitch font
+ Hiding headline leading stars
+ Hiding line numbers
+ Removing outline indentation
+ Centring the text
+ Turning on ~org-pretty-table-mode~

#+begin_src emacs-lisp
(defvar +zen-serif-p t
"Whether to use a serifed font with `mixed-pitch-mode'.")
(after! writeroom-mode
(defvar-local +zen--original-org-indent-mode-p nil)
(defvar-local +zen--original-mixed-pitch-mode-p nil)
(defvar-local +zen--original-org-pretty-table-mode-p nil)
(defun +zen-enable-mixed-pitch-mode-h ()
"Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
(when (apply #'derived-mode-p +zen-mixed-pitch-modes)
(if writeroom-mode
(progn
(setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
(funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
(funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1)))))
(pushnew! writeroom--local-variables
'display-line-numbers
'visual-fill-column-width
'org-adapt-indentation
'org-superstar-remove-leading-stars)
(add-hook 'writeroom-mode-enable-hook
(defun +zen-prose-org-h ()
"Reformat the current Org buffer appearance for prose."
(when (eq major-mode 'org-mode)
(setq display-line-numbers nil
visual-fill-column-width 100
org-adapt-indentation nil)
(when (featurep 'org-superstar)
(setq-local org-superstar-remove-leading-stars t)
(org-superstar-restart))
(setq
+zen--original-org-indent-mode-p org-indent-mode
+zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
(org-indent-mode -1)
(org-pretty-table-mode 1))))
(add-hook 'writeroom-mode-disable-hook
(defun +zen-nonprose-org-h ()
"Reverse the effect of `+zen-prose-org'."
(when (eq major-mode 'org-mode)
(when (featurep 'org-superstar)
(org-superstar-restart))
(when +zen--original-org-indent-mode-p (org-indent-mode 1))
;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
))))
#+end_src

#+attr_html: :class invertible :alt Writeroom applied to an Org file
[[https://tecosaur.com/lfs/emacs-config/screenshots/writeroom-and-org.png]]

*** Treemacs
#+begin_quote
From the =:ui treemacs= module.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! lsp-treemacs)
#+end_src

Quite often there are superfluous files I'm not that interested in. There's no
good reason for them to take up space. Let's add a mechanism to ignore them.
#+begin_src emacs-lisp
(after! treemacs
(defvar treemacs-file-ignore-extensions '()
"File extension which `treemacs-ignore-filter' will ensure are ignored")
(defvar treemacs-file-ignore-globs '()
"Globs which will are transformed to `treemacs-file-ignore-regexps' which `treemacs-ignore-filter' will ensure are ignored")
(defvar treemacs-file-ignore-regexps '()
"RegExps to be tested to ignore files, generated from `treeemacs-file-ignore-globs'")
(defun treemacs-file-ignore-generate-regexps ()
"Generate `treemacs-file-ignore-regexps' from `treemacs-file-ignore-globs'"
(setq treemacs-file-ignore-regexps (mapcar 'dired-glob-regexp treemacs-file-ignore-globs)))
(if (equal treemacs-file-ignore-globs '()) nil (treemacs-file-ignore-generate-regexps))
(defun treemacs-ignore-filter (file full-path)
"Ignore files specified by `treemacs-file-ignore-extensions', and `treemacs-file-ignore-regexps'"
(or (member (file-name-extension file) treemacs-file-ignore-extensions)
(let ((ignore-file nil))
(dolist (regexp treemacs-file-ignore-regexps ignore-file)
(setq ignore-file (or ignore-file (if (string-match-p regexp full-path) t nil)))))))
(add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-filter))
#+end_src

Now, we just identify the files in question.
#+begin_src emacs-lisp
(setq treemacs-file-ignore-extensions
'(;; LaTeX
"aux"
"ptc"
"fdb_latexmk"
"fls"
"synctex.gz"
"toc"
;; LaTeX - glossary
"glg"
"glo"
"gls"
"glsdefs"
"ist"
"acn"
"acr"
"alg"
;; LaTeX - pgfplots
"mw"
;; LaTeX - pdfx
"pdfa.xmpi"
))
(setq treemacs-file-ignore-globs
'(;; LaTeX
"*/_minted-*"
;; AucTeX
"*/.auctex-auto"
"*/_region_.log"
"*/_region_.tex"))


(use-package! lsp-treemacs
:commands lsp-treemacs-errors-list
:config
(lsp-treemacs-sync-mode 1))
#+end_src
* Language Configuration
** General
*** File Templates
For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.
#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src
** Plaintext
It's nice to see ANSI colour codes displayed. However, until Emacs 28 it's not
possible to do this without modifying the buffer, so let's condition this block
on that.
#+begin_src emacs-lisp :tangle (if (>= emacs-major-version 28) "yes" "no")
(after! text-mode
(add-hook! 'text-mode-hook
;; Apply ANSI color codes
(with-silent-modifications
(ansi-color-apply-on-region (point-min) (point-max) t))))
#+end_src
** Haskell
#+begin_quote
From the =:lang haskell= module.
#+end_quote

Haskell is the most balanced language I have used.
Let's bring it to our world.

Currently the =haskell.el= doesn't recongize =.hs-boot= files.
#+begin_src emacs-lisp
(use-package! haskell-mode :mode "\\.hs-boot\\'")
#+end_src

It's nice to make use of the Unicode characters for some keywords.
#+begin_src emacs-lisp
(use-package! haskell-mode
:config
(set-ligatures! 'haskell-mode
;; Functional
:delta "delta"
:lambda "\\"
:left-composition "<<<"
:right-composition ">>>"
;; Logical
:forall "forall"
:exists "exists"
:and "&&"
:or "||"
:not "not"
;; Algebraic
:not-equal "/="
;; Types
:int "Int"
:int "Integer"
:int "Int8"
:int "Int16"
:int "Int32"
:int "Int64"
:void "Void"
:bool "Bool"
:true "True"
:false "False"
:bottom "undefined"
;; Brand
:monarch "Monarch"))
#+end_src

There seems be an issue with the Haskell file template. This will patch it.
#+begin_src emacs-lisp
(add-hook! 'haskell-mode-hook 'haskell-auto-insert-module-template)
#+end_src

Some Haskell specific LSP configurations.
#+begin_src emacs-lisp
(use-package! lsp-haskell
:config
(setq lsp-haskell-server-path "haskell-language-server-wrapper"
lsp-haskell-liquid-on t
lsp-haskell-formatting-provider "stylish-haskell"))
#+end_src

Finally it's a good idea to add =cabal.project= as a root determinant file to the projectile.
#+begin_src emacs-lisp
(after! projectile
(add-to-list 'projectile-project-root-files "cabal.project"))
#+end_src
** PureScript
#+begin_quote
From the =:lang purescript= module.
#+end_quote

By default the major mode trying to use the globally installed PureScript compiler and Spago. As we are empowering the Nix it's not desirable.
#+begin_src emacs-lisp
(use-package! purescript-mode
:config
(setq psc-ide-use-npm-bin t))
#+end_src

And why not pretty symbols?
#+begin_src emacs-lisp
(use-package! purescript-mode
:config
(set-ligatures! 'purescript-mode
;; Functional
:delta "delta"
:lambda "\\"
:left-composition "<<<"
:right-composition ">>>"
;; Logical
:forall "forall"
:exists "exists"
:and "&&"
:or "||"
:not "not"
;; Algebraic
:not-equal "/="
;; Types
:int "Int"
:int "Integer"
:int8 "Int8"
:int16 "Int16"
:int32 "Int32"
:int64 "Int64"
:void "Void"
:bool "Bool"
:true "true"
:false "false"
:bottom "undefined"
;; Brand
:monarch "Monarch")
(setq purescript-font-lock-prettify-symbols-alist (alist-get 'purescript-mode +ligatures-extra-alist)))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! format-all
:recipe (:host github :repo "lassik/emacs-format-all-the-code")
:pin "6200b91d9151b3177a676d30edd948266292bcc1")
#+end_src

I like ~purs-tidy~ as formatter.
#+begin_src emacs-lisp
(add-hook 'purescript-mode-hook #'format-all-mode)
(setq-hook! 'purescript-mode-hook +format-with 'purs-tidy)
#+end_src
** Dhall
#+begin_src emacs-lisp
(use-package! dhall-mode
:init
(add-hook 'dhall-mode #'lsp!)
:config
(setq dhall-format-arguments (\` ("--ascii"))
dhall-use-header-line nil))
#+end_src
** Markdown
Most of the time when I write markdown, it's going into some app/website which
will do it's own line wrapping, hence we /only/ want to use visual line wrapping. No hard stuff.
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'visual-line-mode #'turn-off-auto-fill)
#+end_src

Since markdown is often seen as rendered HTML, let's try to somewhat mirror the
style or markdown renderers.

Most markdown renders seem to make the first three headings levels larger than
normal text, the first two much so. Then the fourth level tends to be the same
as body text, while the fifth and sixth are (increasingly) smaller, with the
sixth greyed out. Since the sixth level is so small, I'll turn up the boldness a notch.
#+begin_src emacs-lisp
(custom-set-faces!
'(markdown-header-face-1 :height 1.25 :weight extra-bold :inherit markdown-header-face)
'(markdown-header-face-2 :height 1.15 :weight bold       :inherit markdown-header-face)
'(markdown-header-face-3 :height 1.08 :weight bold       :inherit markdown-header-face)
'(markdown-header-face-4 :height 1.00 :weight bold       :inherit markdown-header-face)
'(markdown-header-face-5 :height 0.90 :weight bold       :inherit markdown-header-face)
'(markdown-header-face-6 :height 0.75 :weight extra-bold :inherit markdown-header-face))
#+end_src
** JavaScript
#+begin_quote
From the =:lang web= module.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! tide :disable t)
(package! rjsx-mode :disable t)
;; (package! js2-mode :disable t)
;; (package! js2-refactor :disable t)
(package! skewer-mode :disable t)

(package! tsi
:recipe (:host github :repo "orzechowskid/tsi.el"))
(package! tsx-mode
:recipe (:host github :repo "orzechowskid/tsx-mode.el" :branch "master"))
(package! apheleia)
(package! origami)
(package! coverlay)
(package! graphql-mode)
(package! company)

(unpin! lsp-mode)
(unpin! lsp-ui)
(unpin! tree-sitter)
(unpin! tree-sitter-langs)
#+end_src


#+begin_src emacs-lisp
;; (after! css-mode
;;   (setq css-indent-offset 2))

;; (after! javascript-mode
;;   (setq javascript-indentation 2
;;         js-indent-level 2))

;; (after! typescript
;;   (setq typescript-indent-level 2))

;; (after! json-mode
;;   (setq javascript-indentation 2
;;         js-indent-level 2))

(setq css-indent-offset 2)
(setq typescript-indent-level 2)
(setq javascript-indentation 2
js-indent-level 2)

(setq-hook! 'typescript-mode-hook typescript-indent-level 2)

(setq indent-tabs-mode nil)
(setq tab-width 2)

(setq-hook! 'typescript-tsx-mode-hook +format-with-lsp nil)
(setq-hook! 'tsx-mode-hook +format-with-lsp nil)
(setq-hook! 'typescript-mode-hook +format-with-lsp nil)
(setq-hook! 'js-mode-hook +format-with-lsp nil)
(setq-hook! 'json-mode-hook +format-with-lsp nil)

(setq-hook! 'typescript-tsx-mode-hook +format-with :none)
(setq-hook! 'tsx-mode-hook +format-with :none)
(setq-hook! 'typescript-mode-hook +format-with :none)
(setq-hook! 'js-mode-hook +format-with :none)
(setq-hook! 'json-mode-hook +format-with :none)

;; (add-hook! js-mode 'lsp!)
;; (add-hook! tsx-mode #'lsp!)

(use-package! tsx-mode
:mode ("\\.tsx\\'" . tsx-mode)
:hook ((tsx-mode . lsp!)
(tsx-mode . rainbow-delimiters-mode)
(tsx-mode . add-node-modules-path))
:custom
(tsx-mode-tsx-auto-tags t)
:init
(set-electric! 'tsx-mode
:chars '(?\} ?\))
:words '("||" "&&")))


#+end_src

Pretty symbols support.
#+begin_src emacs-lisp
;; (add-hook! 'after-init-hook
;;   (progn
;;     (add-hook! 'typescript-tsx-mode-hook 'tsx-mode)))

;; (add-hook! 'after-init-hook
;;            (progn
;;   (setq-hook! 'typescript-mode-hook +format-with :nil)
;;   (add-hook! 'typescript-mode-hook 'prettier-mode)
;;   (setq-hook! 'rjsx-mode-hook +format-with :nil)
;;   (add-hook! 'rjsx-mode-hook 'prettier-mode)
;;   (setq-hook! 'js2-mode-hook +format-with :nil)
;;   (add-hook! 'js2-mode-hook 'prettier-mode)
;;   (setq-hook! 'typescript-tsx-mode-hook +format-with :nil)
;;   (add-hook! 'typescript-tsx-mode-hook 'prettier-mode)
;;   (setq-hook! 'tsx-mode-hook +format-with :nil)
;;   (add-hook! 'tsx-mode-hook 'prettier-mode)
;;   ))

;; (use-package! typescript-mode
;;   :mode ("\\.tsx\\'" . typescript-tsx-tree-sitter-mode)
;;   :config
;;   (setq typescript-indent-level 2)

;;   (define-derived-mode typescript-tsx-tree-sitter-mode typescript-mode "TypeScript TSX"
;;     (setq-local indent-line-function 'rjsx-indent-line))

;;   (add-hook! 'typescript-tsx-tree-sitter-mode-local-vars-hook
;;              #'+javascript-init-lsp-or-tide-maybe-h
;;              #'rjsx-minor-mode)
;;   (map! :map typescript-tsx-tree-sitter-mode-map
;;         "<" 'rjsx-electric-lt
;;         ">" 'rjsx-electric-gt))

;; (after! tree-sitter
;;   (add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-tree-sitter-mode . tsx)))

;; (setq-hook! 'typescript-mode-hook +format-with-lsp nil)
;; (setq-hook! 'typescript-tsx-mode-hook +format-with-lsp nil)
;; (setq-hook! 'typescript-mode-hook +format-with 'prettier)
;; (setq-hook! 'typescript-tsx-mode-hook +format-with 'prettier)

;; (dolist (feature '(rjsx-mode
;;                    typescript-mode
;;                    typescript-tsx-mode
;;                    web-mode
;;                    js2-mode
;;                    (nodejs-repl-mode . nodejs-repl)))
;;   (let ((pkg  (or (cdr-safe feature) feature))
;;         (mode (or (car-safe feature) feature)))
;;     (with-eval-after-load pkg
;;       (set-ligatures! mode
;;         ;; Functional
;;         :defalt "delta"
;;         :lambda "() =>"
;;         :function "function"
;;         ;; Logical
;;         :not "!"
;;         :and "&&"
;;         :or "||"
;;         :import "import"
;;         :export "export"
;;         ;; Types
;;         :int "number"
;;         :bool "boolean"
;;         :true "true"
;;         :false "false"
;;         :bottom "throw"
;;         ;; Brand
;;         :monarch "Monarch"))))

(defun my/use-eslint-from-node-modules ()
(let* ((root (locate-dominating-file
(or (buffer-file-name) default-directory)
"node_modules"))
(eslint (and root
(expand-file-name "node_modules/eslint/bin/eslint.js"
root))))
(when (and eslint (file-executable-p eslint))
(setq-local flycheck-javascript-eslint-executable eslint))))
(add-hook! 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
#+end_src

** Org
*** Export
#+begin_src emacs-lisp
(after! ox
(add-to-list 'org-export-filter-timestamp-functions
#'endless/filter-timestamp)
(defun endless/filter-timestamp (trans back _comm)
"Remove <> around time-stamps."
(pcase back
((or `jekyll `html)
(replace-regexp-in-string "&[lg]t;" "" trans))
(`latex
(replace-regexp-in-string "[<>]" "" trans))))
)

(setq-default org-display-custom-times t)
;;; Before you ask: No, removing the <> here doesn't work.
(setq org-time-stamp-custom-formats
'("<%d %b %Y>" . "<%d/%m/%y %a %H:%M>"))
#+end_src
*** Citation
#+begin_src emacs-lisp
(setq org-cite-csl-styles-dir "~/Zotero/styles")
(setq! citar-bibliography '("~/Zotero/library.bib"))
#+end_src
